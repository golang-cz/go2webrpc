package parser

import (
	"go/types"
	"path/filepath"
	"strings"
	"unicode"
	"unicode/utf8"
)

func (p *Parser) GoTypeName(typ types.Type) string {
	name := typ.String() // []*github.com/golang-cz/gospeak/pkg.Typ

	if typNamed, ok := typ.(*types.Named); ok {
		// Versioned packages.
		// github.com/gofrs/uuid/v5.UUID => // github.com/gofrs/uuid.UUID
		if typNamed.Obj().Pkg() != nil {
			if !strings.Contains(name, typNamed.Obj().Pkg().Name()+".") {
				name = strings.ReplaceAll(name, typNamed.Obj().Type().String(), typNamed.Obj().Pkg().Name()+"."+typNamed.Obj().Name())
			}
		}
	}

	name = strings.ReplaceAll(name, "*", "") // []github.com/golang-cz/gospeak/pkg.Typ

	firstLetter := findFirstLetter(name)
	prefix := name[:firstLetter] // []
	name = name[firstLetter:]    // github.com/golang-cz/gospeak/pkg.Typ

	name = strings.TrimPrefix(name, p.SchemaPkgName+".")       // Typ (ignore root Pkg)
	name = strings.TrimPrefix(name, "command-line-arguments.") // Typ (ignore "command-line-arguments" Pkg autogenerated by Go tool chain)
	name = filepath.Base(name)                                 // pkg.Typ

	if name == "invalid type" {
		name = "invalidType"
	}

	return prefix + name // []*pkg.Typ
}

func (p *Parser) GoTypeImport(typ types.Type) string {
	name := typ.String() // []*github.com/golang-cz/gospeak/pkg.Typ

	firstLetter := findFirstLetter(name)
	name = name[firstLetter:] // github.com/golang-cz/gospeak/pkg.Typ

	lastDot := strings.LastIndex(name, ".")
	if lastDot <= 0 {
		return ""
	}

	name = name[:lastDot] // github.com/golang-cz/gospeak/pkg
	switch name {
	case p.SchemaPkgName, "command-line-arguments", "time":
		return ""
	}

	return name
}

func (p *Parser) GoTypeNameToWebrpc(typ string) string {
	typ = strings.Trim(typ, "[]*.")
	typ = filepath.Base(typ)
	before, after, _ := strings.Cut(typ, ".")
	return before + after
}

func findFirstLetter(s string) int {
	for i, char := range s {
		if unicode.IsLetter(char) {
			return i
		}
	}
	return 0
}

func firstToLower(s string) string {
	orig, size := utf8.DecodeRuneInString(s)
	if orig == utf8.RuneError && size <= 1 {
		return s
	}
	lower := unicode.ToLower(orig)
	if orig == lower {
		return s
	}
	return string(lower) + s[size:]
}
